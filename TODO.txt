

 - To separate between the actual game and editor, create the ability to add command line arguments to differentiate between the two

 - At some point it might be nice to try and figure out how to import raymarching for ultimate pretty

 - So what if we had two windows

How does this correlate to the idea you had that you wanted to communicate?
 

 - SetWindowPosition() is a function you can use to set the window position on the monitor
 - For the interaction system you can use function pointers inside of structs and do stuff that way



Sadly, raylib does not support multiple windows in one instance
What you can do instead is create multiple executables and then create some sort of file to transfer data over from one executable to the other

system("file.exe") will run the executable, it's included in <stdlib.h>




What is our best course of action here:




 Make it so when you interact, it interacts with the first thing hit rather than the last bc if you try to interact with the puzzle atm from an angle that allows the ray
 to go through another box, it will interact with that box instead of the one with the puzzle in it

Do the assignation of the button symbols after the all of the assigning of the buttons materials and such

Design a rule for a puzzle for the beginning


Figure out how to $(SolutionDir) things to make it possible for other machines to get the imported info for things like models and textures

It would also probably be nice if you made the player a little taller

Create some sort of gate (a door, or maybe a platform that appears) to prevent the player from moving forward without having to solve any puzzles


Rename NUMBER_OF_MODELS and NUMBER_OF_PUZZLES for both A and B type games

Separate interactable into gamea and gameb 

